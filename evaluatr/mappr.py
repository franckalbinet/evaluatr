"""Scale up evaluation report mapping against evaluation frameworks using agentic workflows"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_mappr.ipynb.

# %% auto 0
__all__ = ['GEMINI_API_KEY', 'cfg', 'lm', 'traces_dir', 'find_section_path', 'get_content_tool', 'format_enabler_theme',
           'Overview', 'Exploration', 'Assessment', 'Phase', 'TraceContext', 'Synthesis', 'setup_logger',
           'setup_trace_logging', 'ThemeAnalyzer']

# %% ../nbs/06_mappr.ipynb 5
from pathlib import Path
from functools import reduce
from toolslm.md_hier import *
from rich import print
import json
from fastcore.all import *
from enum import Enum
import logging
import uuid
from datetime import datetime
from typing import List, Callable
import dspy
import asyncio
import time

from .frameworks import (EvalData, 
                                 IOMEvalData, 
                                 FrameworkInfo, 
                                 Framework,
                                 FrameworkCat)

# %% ../nbs/06_mappr.ipynb 6
from dotenv import load_dotenv
import os

load_dotenv()
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')

# %% ../nbs/06_mappr.ipynb 7
cfg = AttrDict({
    'lm': 'gemini/gemini-2.0-flash-exp',
    'api_key': GEMINI_API_KEY,
    'max_tokens': 8192,
    'track_usage': False,
    'rpm_limit': 15, 
    'call_delay': 6,
    'dirs': AttrDict({
        'data': '.evaluator',
        'trace': 'traces'
    }),
    'verbosity': 1,
    'cache': AttrDict({
        'is_active': True,
        'delay': 0.1 # threshold in seconds below which we consider the response is cached
    })
})

# %% ../nbs/06_mappr.ipynb 8
lm = dspy.LM(cfg.lm, api_key=cfg.api_key, cache=cfg.cache.is_active)
dspy.configure(lm=lm)

# %% ../nbs/06_mappr.ipynb 13
def find_section_path(
    hdgs: dict, # The nested dictionary structure
    target_section: str # The section name to find
) -> list: # The nested key path for the given section name
    "Find the nested key path for a given section name."
    def search_recursive(current_dict, path=[]):
        for key, value in current_dict.items():
            current_path = path + [key]
            if key == target_section:
                return current_path
            if isinstance(value, dict):
                result = search_recursive(value, current_path)
                if result:
                    return result
        return None
    
    return search_recursive(hdgs)

# %% ../nbs/06_mappr.ipynb 17
def get_content_tool(
    hdgs: dict, # The nested dictionary structure
    keys_list: list, # The list of keys to navigate through
    ) -> str: # The content of the section
    "Navigate through nested levels using the exact key strings."
    return reduce(lambda current, key: current[key], keys_list, hdgs).text

# %% ../nbs/06_mappr.ipynb 21
def format_enabler_theme(
    theme: EvalData # The theme object
    ) -> str: # The formatted theme string
    "Format SRF enabler into structured text for LM processing."
    parts = [
        f'## Enabler {theme.id}: {theme.title}',
        '### Description', 
        theme.description
    ]
    return '\n'.join(parts)

# %% ../nbs/06_mappr.ipynb 26
class Overview(dspy.Signature):
    "Based on framework theme to map and report's TOC determine the sections to explore first."
    theme: str = dspy.InputField(desc="Theme being analyzed")
    all_headings: str = dspy.InputField(desc="Complete document structure")
    priority_sections: List[str] = dspy.OutputField(desc="Ordered list of section keys to explore first")
    strategy: str = dspy.OutputField(desc="Reasoning for this exploration strategy")

# %% ../nbs/06_mappr.ipynb 29
class Exploration(dspy.Signature):
    "Decide next exploration step for theme to be mapped based on current findings and available sections."
    theme: str = dspy.InputField(desc="Theme being analyzed")
    current_findings: str = dspy.InputField(desc="Evidence found so far")
    available_sections: str = dspy.InputField(desc="Remaining sections to explore")
    next_section: str = dspy.OutputField(desc="Next section key to explore, or 'DONE' if sufficient")
    reasoning: str = dspy.OutputField(desc="Why this section or why stopping")

# %% ../nbs/06_mappr.ipynb 31
class Assessment(dspy.Signature):
    "Assess if current evidence is sufficient for theme analysis."
    theme: str = dspy.InputField(desc="Theme being analyzed")
    evidence_so_far: str = dspy.InputField(desc="All evidence collected")
    sections_explored: str = dspy.InputField(desc="Sections already checked")
    sufficient: bool = dspy.OutputField(desc="Is evidence sufficient to make conclusion?")
    confidence_score: float = dspy.OutputField(desc="Confidence in current findings (0-1)")
    next_priority: str = dspy.OutputField(desc="If continuing, what type of section to prioritize")
    reasoning: str = dspy.OutputField(desc="Why this assessment was made")

# %% ../nbs/06_mappr.ipynb 33
class Phase(Enum):
    "Pipeline phase number."
    STAGE1 = 1
    STAGE2 = 2
    STAGE3 = 3

# %% ../nbs/06_mappr.ipynb 34
class TraceContext(AttrDict):
    "Context for tracing the mapping process"
    def __init__(self, 
                 report_id:str,  # Report identifier
                 phase_nb:Phase,  # Pipeline phase number
                 framework:FrameworkInfo,  # Framework info (name, category, theme_id)
                 ): 
        self.run_id = str(uuid.uuid4())[:8]  # Short unique ID
        store_attr()
    
    def __repr__(self):
        return f"TraceContext(run_id={self.run_id}, report_id={self.report_id}, phase_nb={self.phase_nb}, framework={self.framework})"

# %% ../nbs/06_mappr.ipynb 36
class Synthesis(dspy.Signature):
    "Provide detailed rationale and synthesis of theme analysis."
    trace_ctx: str = dspy.InputField(desc="Trace context")
    theme: str = dspy.InputField(desc="Theme being analyzed")
    all_evidence: str = dspy.InputField(desc="All collected evidence")
    sections_explored: str = dspy.InputField(desc="List of sections explored")
    theme_covered: bool = dspy.OutputField(desc="Final decision on theme coverage")
    confidence_explanation: str = dspy.OutputField(desc="Detailed explanation of confidence score")
    evidence_summary: str = dspy.OutputField(desc="Key evidence supporting the conclusion")
    gaps_identified: str = dspy.OutputField(desc="Any gaps or missing aspects")

# %% ../nbs/06_mappr.ipynb 39
traces_dir = Path.home() / cfg.dirs.data / cfg.dirs.trace
traces_dir.mkdir(parents=True, exist_ok=True)

# %% ../nbs/06_mappr.ipynb 40
def setup_logger(name, handler, level=logging.INFO, **kwargs):
    "Helper function to setup a logger with common configuration"
    logger = logging.getLogger(name)
    logger.handlers.clear()
    logger.addHandler(handler)
    logger.setLevel(level)
    for k,v in kwargs.items(): setattr(logger, k, v)
    return logger

# %% ../nbs/06_mappr.ipynb 41
def setup_trace_logging(report_id, verbosity=cfg.verbosity):
    "Setup the trace logging (verbosity and report_id)"
    file_handler = logging.FileHandler(traces_dir / f'{report_id}.jsonl', mode='w')
    
    
    setup_logger('trace.file', file_handler)
    
    console_handler = logging.StreamHandler()
    setup_logger('trace.console', console_handler, verbosity=verbosity)

# %% ../nbs/06_mappr.ipynb 42
class ThemeAnalyzer(dspy.Module):
    """
    Analyzes a theme across a document by iteratively exploring sections, collecting evidence, and synthesizing findings. 
    Uses a structured pipeline of overview -> exploration -> assessment -> synthesis.
    """
    def __init__(self, 
                 overview_sig:dspy.Signature, # Overview signature
                 exploration_sig:dspy.Signature, # Exploration signature
                 assessment_sig:dspy.Signature, # Assessment signature
                 synthesis_sig:dspy.Signature, # Synthesis signature
                 trace_ctx:TraceContext, # Trace context
                 confidence_threshold:float=0.8, # Confidence threshold
                 max_iter:int=10, # Maximum number of iterations in the ReAct loop
                 semaphore=None # Semaphore for rate limiting
                 ):
        self.overview = dspy.ChainOfThought(overview_sig)
        self.explore = dspy.ChainOfThought(exploration_sig)
        self.assess = dspy.ChainOfThought(assessment_sig)
        self.synthesize = dspy.ChainOfThought(synthesis_sig)
        self.max_iter = max_iter
        self.trace_ctx = trace_ctx
        self.confidence_threshold = confidence_threshold
        self.semaphore = semaphore

# %% ../nbs/06_mappr.ipynb 43
@patch
def _log_trace(self:ThemeAnalyzer, event, **extra_data):
    file_logger = logging.getLogger('trace.file')
    console_logger = logging.getLogger('trace.console')
    
    base_data = {
        "run_id": self.trace_ctx.run_id,
        "timestamp": datetime.now().isoformat(),
        "event": event,
        "report_id": self.trace_ctx.report_id,
        "phase_nb": str(self.trace_ctx.phase_nb),
        "framework": str(self.trace_ctx.framework.name),
        "framework_category": str(self.trace_ctx.framework.category),
        "framework_theme_id": str(self.trace_ctx.framework.theme_id),
    }
    base_data.update(extra_data)
    
    # File logger - always full JSON
    file_logger.info(json.dumps(base_data, indent=2))
    
    # Console logger - verbosity-based formatting
    if hasattr(console_logger, 'verbosity'):
        if console_logger.verbosity == 1:
            console_msg = f"{base_data['report_id']} - {base_data['phase_nb']}"
        elif console_logger.verbosity == 2:
            console_msg = f"{base_data['report_id']} - {base_data['phase_nb']} - {base_data['framework']} - {base_data['framework_theme_id']} - {base_data['event']}"
        else:  # verbosity == 3
            console_msg = json.dumps(base_data, indent=2)
        
        console_logger.info(console_msg)

# %% ../nbs/06_mappr.ipynb 44
@patch    
async def _rate_limited_fn(self:ThemeAnalyzer, mod, **kwargs):
    async with self.semaphore:
        start = time.time()
        result = await mod.acall(**kwargs)
        
        # Check if cached (fast response + no usage)
        elapsed = time.time() - start
        if elapsed > cfg.cache.delay: await asyncio.sleep(cfg.call_delay)
        return result

# %% ../nbs/06_mappr.ipynb 45
@patch
async def aforward(
    self:ThemeAnalyzer, 
    theme: str, # The formatted theme to analyze
    headings: dict, # The headings TOC of the document
    get_content_fn:Callable=get_content_tool, # The function to get the content of a section using `hdgs[keys_list].text` for instance
    ) -> Synthesis: # Synthesized analysis results including theme coverage, confidence, evidence and gaps
    "Executes a structured analysis process."
    self._log_trace(event="Starting Analysis", theme=theme)
    priority_sections = await self.get_overview(theme, headings)
    evidence = await self.explore_iteratively(theme, priority_sections, headings, get_content_fn)
    return await self.synthesize_findings(theme, evidence)

# %% ../nbs/06_mappr.ipynb 46
@patch
async def get_overview(
    self:ThemeAnalyzer, 
    theme: str, # The formatted theme to analyze
    headings: dict, # The headings TOC of the document
    ) -> Overview:
    "Based on framework theme to map and report's TOC determine the sections to explore first."
    overview = await self._rate_limited_fn(self.overview, theme=theme, all_headings=str(headings))
    self._log_trace(
        event="Overview", 
        priority_sections=overview.priority_sections, 
        strategy=overview.strategy)
    return overview.priority_sections

# %% ../nbs/06_mappr.ipynb 47
@patch
async def explore_iteratively(
    self:ThemeAnalyzer, 
    theme: str, # The formatted theme to analyze
    priority_sections: list, # The sections to explore first
    headings: dict, # The headings TOC of the document
    get_content_fn: Callable, # The function to get the content of a section using `hdgs[keys_list].text` for instance
    ) -> dict:
    "Iteratively explore the sections to collect evidence."
    evidence_collected = []
    sections_explored = []
    available_sections = priority_sections.copy()
    
    for i in range(self.max_iter):
        if not available_sections:
            self._log_trace(event="Iterative Exploration", iteration_nb=i+1, decision="No more sections to explore, stopping")
            break
            
        if await self.should_stop_exploring(theme, evidence_collected, sections_explored):   
            break
        
        decision = await self.make_exploration_decision(theme, evidence_collected, available_sections)
        self._log_trace(
            event="Iterative Exploration", 
            iteration_nb=i+1, 
            decision=decision.next_section, 
            reasoning=decision.reasoning)
        
        if decision.next_section == 'DONE':
            self._log_trace(event="Iterative Exploration", iteration_nb=i+1, decision="Done")
            break
        
        evidence_collected, sections_explored = self.process_section(decision, 
                                                                     headings, 
                                                                     get_content_fn, 
                                                                     evidence_collected, 
                                                                     sections_explored, 
                                                                     available_sections)
    
    return {"evidence": evidence_collected, "sections": sections_explored}


# %% ../nbs/06_mappr.ipynb 48
@patch
async def make_exploration_decision(
    self:ThemeAnalyzer, 
    theme: str, # The formatted theme to analyze
    evidence_collected: list, # The evidence collected so far
    available_sections: list # The sections to explore
    ):    
    "Make a decision on the next section to explore."
    decision = await self._rate_limited_fn(
        self.explore, 
        theme=theme, 
        current_findings="\n\n".join(evidence_collected) if evidence_collected else "No evidence collected yet", available_sections=str(available_sections))
    
    return decision


# %% ../nbs/06_mappr.ipynb 49
@patch
async def should_stop_exploring(
    self:ThemeAnalyzer, 
    theme: str, # The formatted theme to analyze
    evidence_collected: list, # The evidence collected so far
    sections_explored: list # The sections explored so far
    ):
    "Check if the exploration should stop based on the evidence collected and the sections explored."
    if not evidence_collected:
        return False
    assessment = await self._rate_limited_fn(
        self.assess, 
        theme=theme,
        evidence_so_far="\n\n".join(evidence_collected),
        sections_explored=str(sections_explored)
    )
    
    self._log_trace(
        "Should stop exploring", 
        assessment=assessment.sufficient, 
        confidence=assessment.confidence_score,
        reasoning=assessment.reasoning
        )
    
    return assessment.sufficient and assessment.confidence_score > self.confidence_threshold

# %% ../nbs/06_mappr.ipynb 50
@patch
def process_section(self:ThemeAnalyzer, decision, headings, get_content_fn, evidence_collected, sections_explored, available_sections):
    path = find_section_path(headings, decision.next_section)
    
    if path:
        content = get_content_fn(headings, path)
        evidence_collected.append(f"# Section: {decision.next_section}\n## Content\n{content}")
        sections_explored.append(decision.next_section)
        if decision.next_section in available_sections:
            available_sections.remove(decision.next_section)
    else:
        # No path found for section! TBD
        pass
    
    return evidence_collected, sections_explored

# %% ../nbs/06_mappr.ipynb 51
@patch
async def synthesize_findings(self:ThemeAnalyzer, theme, evidence):
    synthesis = await self._rate_limited_fn(
        self.synthesize, 
        trace_ctx=str(self.trace_ctx),
        theme=theme,
        all_evidence="\n\n".join(evidence["evidence"]),
        sections_explored=str(evidence["sections"])
    )
    
    self._log_trace("Synthesis", 
                    theme=theme, 
                    reasoning=synthesis.reasoning,
                    theme_covered=synthesis.theme_covered,
                    confidence_explanation=synthesis.confidence_explanation,
                    evidence_summary=synthesis.evidence_summary,
                    gaps_identified=synthesis.gaps_identified
                    )
    synthesis.framework_name = self.trace_ctx.framework.name
    synthesis.framework_category = self.trace_ctx.framework.category  
    synthesis.framework_theme_id = self.trace_ctx.framework.theme_id
    return synthesis

# %% ../nbs/06_mappr.ipynb 71
# class PipelineResults:
#     def __init__(self):
#         self.stage1 = AttrDict({FrameworkCat.ENABLERS: {}, FrameworkCat.CROSSCUT: {}})
#         self.stage2 = AttrDict({"gcm_objectives": {}})
#         self.stage3 = AttrDict({"srf_outputs": {}})
