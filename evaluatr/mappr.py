"""Scale up evaluation report mapping against evaluation frameworks using agentic workflows"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_mappr.ipynb.

# %% auto 0
__all__ = ['GEMINI_API_KEY', 'cfg', 'lm', 'trace_logger', 'handler', 'find_section_path', 'get_content_tool',
           'format_enabler_theme', 'Overview', 'Exploration', 'Assessment', 'Phase', 'TraceContext', 'Synthesis',
           'ThemeAnalyzer']

# %% ../nbs/06_mappr.ipynb 5
from pathlib import Path
from functools import reduce
from toolslm.md_hier import *
from rich import print
import json
from fastcore.all import *
from enum import Enum
import logging
import uuid
from datetime import datetime
from typing import List
import dspy
import asyncio

from .frameworks import EvalData, IOMEvalData, FrameworkInfo

# %% ../nbs/06_mappr.ipynb 6
from dotenv import load_dotenv
import os

load_dotenv()
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')

# %% ../nbs/06_mappr.ipynb 7
cfg = AttrDict({
    'lm': 'gemini/gemini-2.0-flash-exp',
    'api_key': GEMINI_API_KEY,
    'max_tokens': 8192,
    'track_usage': False,
    'rpm_limit': 15, 
    'call_delay': 6
})

# %% ../nbs/06_mappr.ipynb 8
lm = dspy.LM(cfg.lm, api_key=cfg.api_key, cache=False)
dspy.configure(lm=lm)

# %% ../nbs/06_mappr.ipynb 13
def find_section_path(
    hdgs: dict, # The nested dictionary structure
    target_section: str # The section name to find
) -> list: # The nested key path for the given section name
    "Find the nested key path for a given section name."
    def search_recursive(current_dict, path=[]):
        for key, value in current_dict.items():
            current_path = path + [key]
            if key == target_section:
                return current_path
            if isinstance(value, dict):
                result = search_recursive(value, current_path)
                if result:
                    return result
        return None
    
    return search_recursive(hdgs)

# %% ../nbs/06_mappr.ipynb 17
def get_content_tool(
    hdgs: dict, # The nested dictionary structure
    keys_list: list, # The list of keys to navigate through
    ) -> str: # The content of the section
    "Navigate through nested levels using the exact key strings."
    return reduce(lambda current, key: current[key], keys_list, hdgs).text

# %% ../nbs/06_mappr.ipynb 21
def format_enabler_theme(
    theme: EvalData # The theme object
    ) -> str: # The formatted theme string
    "Format SRF enabler into structured text for LM processing."
    parts = [
        f'## Enabler {theme.id}: {theme.title}',
        '### Description', 
        theme.description
    ]
    return '\n'.join(parts)

# %% ../nbs/06_mappr.ipynb 26
class Overview(dspy.Signature):
    "Based on framework theme to map and report's TOC determine the sections to explore first."
    theme: str = dspy.InputField(desc="Theme being analyzed")
    all_headings: str = dspy.InputField(desc="Complete document structure")
    priority_sections: List[str] = dspy.OutputField(desc="Ordered list of section keys to explore first")
    strategy: str = dspy.OutputField(desc="Reasoning for this exploration strategy")

# %% ../nbs/06_mappr.ipynb 29
class Exploration(dspy.Signature):
    "Decide next exploration step for theme to be mapped based on current findings and available sections."
    theme: str = dspy.InputField(desc="Theme being analyzed")
    current_findings: str = dspy.InputField(desc="Evidence found so far")
    available_sections: str = dspy.InputField(desc="Remaining sections to explore")
    next_section: str = dspy.OutputField(desc="Next section key to explore, or 'DONE' if sufficient")
    reasoning: str = dspy.OutputField(desc="Why this section or why stopping")

# %% ../nbs/06_mappr.ipynb 31
class Assessment(dspy.Signature):
    "Assess if current evidence is sufficient for theme analysis."
    theme: str = dspy.InputField(desc="Theme being analyzed")
    evidence_so_far: str = dspy.InputField(desc="All evidence collected")
    sections_explored: str = dspy.InputField(desc="Sections already checked")
    sufficient: bool = dspy.OutputField(desc="Is evidence sufficient to make conclusion?")
    confidence_score: float = dspy.OutputField(desc="Confidence in current findings (0-1)")
    next_priority: str = dspy.OutputField(desc="If continuing, what type of section to prioritize")

# %% ../nbs/06_mappr.ipynb 33
class Phase(Enum):
    "Pipeline phase number."
    STAGE1 = 1
    STAGE2 = 2
    STAGE3 = 3

# %% ../nbs/06_mappr.ipynb 34
class TraceContext(AttrDict):
    "Context for tracing the mapping process"
    def __init__(self, 
                 report_id:str,  # Report identifier
                 phase_nb:Phase,  # Pipeline phase number
                 framework:FrameworkInfo,  # Framework info (name, category, theme_id)
                 ): 
        self.run_id = str(uuid.uuid4())[:8]  # Short unique ID
        store_attr()
    
    def __repr__(self):
        return f"TraceContext(run_id={self.run_id}, report_id={self.report_id}, phase_nb={self.phase_nb}, framework={self.framework})"

# %% ../nbs/06_mappr.ipynb 36
class Synthesis(dspy.Signature):
    "Provide detailed rationale and synthesis of theme analysis."
    trace_ctx: str = dspy.InputField(desc="Trace context")
    theme: str = dspy.InputField(desc="Theme being analyzed")
    all_evidence: str = dspy.InputField(desc="All collected evidence")
    sections_explored: str = dspy.InputField(desc="List of sections explored")
    theme_covered: bool = dspy.OutputField(desc="Final decision on theme coverage")
    confidence_explanation: str = dspy.OutputField(desc="Detailed explanation of confidence score")
    evidence_summary: str = dspy.OutputField(desc="Key evidence supporting the conclusion")
    gaps_identified: str = dspy.OutputField(desc="Any gaps or missing aspects")

# %% ../nbs/06_mappr.ipynb 39
trace_logger = logging.getLogger('trace')
trace_logger.setLevel(logging.INFO)
handler = logging.StreamHandler()
if not trace_logger.handlers:
    handler = logging.StreamHandler()
    trace_logger.addHandler(handler)

# %% ../nbs/06_mappr.ipynb 40
class ThemeAnalyzer(dspy.Module):
    """
    Analyzes a theme across a document by iteratively exploring sections, collecting evidence, and synthesizing findings. 
    Uses a structured pipeline of overview -> exploration -> assessment -> synthesis.
    """
    def __init__(self, 
                 overview_sig:dspy.Signature, # Overview signature
                 exploration_sig:dspy.Signature, # Exploration signature
                 assessment_sig:dspy.Signature, # Assessment signature
                 synthesis_sig:dspy.Signature, # Synthesis signature
                 trace_ctx:TraceContext, # Trace context
                 confidence_threshold:float=0.8, # Confidence threshold
                 max_iter:int=10, # Maximum number of iterations in the ReAct loop
                 semaphore=None # Semaphore for rate limiting
                 ):
        self.overview = dspy.ChainOfThought(overview_sig)
        self.explore = dspy.ChainOfThought(exploration_sig)
        self.assess = dspy.ChainOfThought(assessment_sig)
        self.synthesize = dspy.ChainOfThought(synthesis_sig)
        self.max_iter = max_iter
        self.trace_ctx = trace_ctx
        self.confidence_threshold = confidence_threshold
        self.semaphore = semaphore

# %% ../nbs/06_mappr.ipynb 41
@patch
async def _rate_limited_fn(self:ThemeAnalyzer, mod, **kwargs):
    async with self.semaphore:
        result = await mod.acall(**kwargs)
        await asyncio.sleep(cfg.call_delay)
        return result

# %% ../nbs/06_mappr.ipynb 42
@patch
async def aforward(
    self:ThemeAnalyzer, 
    theme: str, # The formatted theme to analyze
    headings: dict, # The headings TOC of the document
    get_content_fn=get_content_tool, # The function to get the content of a section using `hdgs[keys_list].text` for instance
    ) -> Synthesis: # Synthesized analysis results including theme coverage, confidence, evidence and gaps
    "Executes a structured analysis process."
    trace_logger.info(json.dumps({
        "run_id": self.trace_ctx.run_id,
        "timestamp": datetime.now().isoformat(),
        "event": "Starting Analysis", 
        "report_id": self.trace_ctx.report_id,
        "phase_nb": str(self.trace_ctx.phase_nb),
        "framework": str(self.trace_ctx.framework.name),
        "framework_category": str(self.trace_ctx.framework.category),
        "theme": theme,
        "framework_theme_id": str(self.trace_ctx.framework.theme_id),
        }, indent=2))

    priority_sections = await self.get_overview(theme, headings)
    evidence = await self.explore_iteratively(theme, priority_sections, headings, get_content_fn)
    return await self.synthesize_findings(theme, evidence)

# %% ../nbs/06_mappr.ipynb 43
@patch
async def get_overview(self:ThemeAnalyzer, theme, headings) -> Overview:
    overview = await self._rate_limited_fn(self.overview, theme=theme, all_headings=str(headings))
    
    trace_logger.info(json.dumps({
        "run_id": self.trace_ctx.run_id,
        "timestamp": datetime.now().isoformat(),    
        "event": "Overview", 
        "priority_sections": overview.priority_sections,
        "strategy": overview.strategy,
        }, indent=2))
    
    return overview.priority_sections

# %% ../nbs/06_mappr.ipynb 44
@patch
async def explore_iteratively(self:ThemeAnalyzer, theme, priority_sections, headings, get_content_fn):
    evidence_collected = []
    sections_explored = []
    available_sections = priority_sections.copy()
    
    for i in range(self.max_iter):
        if not available_sections:
            trace_logger.info(json.dumps({
                "run_id": self.trace_ctx.run_id,
                "timestamp": datetime.now().isoformat(),
                "event": "Iterative Exploration", 
                "iteration_nb": i+1,
                "decision": "No more sections to explore, stopping",
                }, indent=2))
            break
        
        if await self.should_stop_exploring(theme, evidence_collected, sections_explored):   
            break
        
        decision = await self.make_exploration_decision(theme, evidence_collected, available_sections)
        trace_logger.info(json.dumps({
                "run_id": self.trace_ctx.run_id,
                "timestamp": datetime.now().isoformat(),
                "event": "Iterative Exploration", 
                "iteration_nb": i+1,
                "decision": decision.next_section,
                "reasoning": decision.reasoning,
                }, indent=2))
        
        
        if decision.next_section == 'DONE':
            trace_logger.info(json.dumps({
                "run_id": self.trace_ctx.run_id,
                "timestamp": datetime.now().isoformat(),
                "event": "Iterative Exploration", 
                "iteration_nb": i+1,
                "decision": "Done",
                }, indent=2))
            break
        
        evidence_collected, sections_explored = self.process_section(decision, 
                                                                     headings, 
                                                                     get_content_fn, 
                                                                     evidence_collected, 
                                                                     sections_explored, 
                                                                     available_sections)
    
    return {"evidence": evidence_collected, "sections": sections_explored}


# %% ../nbs/06_mappr.ipynb 45
@patch
async def make_exploration_decision(self:ThemeAnalyzer, theme, evidence_collected, available_sections):    
    decision = await self._rate_limited_fn(
        self.explore, 
        theme=theme, 
        current_findings="\n\n".join(evidence_collected) if evidence_collected else "No evidence collected yet", available_sections=str(available_sections))
    
    return decision


# %% ../nbs/06_mappr.ipynb 46
@patch
async def should_stop_exploring(self:ThemeAnalyzer, theme, evidence_collected, sections_explored):
    if not evidence_collected:
        return False
    assessment = await self._rate_limited_fn(
        self.assess, 
        theme=theme,
        evidence_so_far="\n\n".join(evidence_collected),
        sections_explored=str(sections_explored)
    )
    
    trace_logger.info(json.dumps({
                "run_id": self.trace_ctx.run_id,
                "timestamp": datetime.now().isoformat(),
                "event": "Should stop exploring", 
                "assessment": assessment.sufficient,
                "confidence": assessment.confidence_score,
                }, indent=2))
    
    return assessment.sufficient and assessment.confidence_score > self.confidence_threshold

# %% ../nbs/06_mappr.ipynb 47
@patch
def process_section(self:ThemeAnalyzer, decision, headings, get_content_fn, evidence_collected, sections_explored, available_sections):
    path = find_section_path(headings, decision.next_section)
    
    if path:
        content = get_content_fn(headings, path)
        evidence_collected.append(f"# Section: {decision.next_section}\n## Content\n{content}")
        sections_explored.append(decision.next_section)
        if decision.next_section in available_sections:
            available_sections.remove(decision.next_section)
    else:
        # No path found for section! TBD
        pass
    
    return evidence_collected, sections_explored

# %% ../nbs/06_mappr.ipynb 48
@patch
async def synthesize_findings(self:ThemeAnalyzer, theme, evidence):
    synthesis = await self._rate_limited_fn(
        self.synthesize, 
        trace_ctx=str(self.trace_ctx),
        theme=theme,
        all_evidence="\n\n".join(evidence["evidence"]),
        sections_explored=str(evidence["sections"])
    )
    

    trace_logger.info(json.dumps({
        "run_id": self.trace_ctx.run_id,
        "timestamp": datetime.now().isoformat(),
        "event": "Synthesis", 
        "theme_covered": synthesis.theme_covered,
        "confidence_explanation": synthesis.confidence_explanation,
        "evidence_summary": synthesis.evidence_summary,
        "gaps_identified": synthesis.gaps_identified,
    }, indent=2))
    return synthesis

