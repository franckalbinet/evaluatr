"""Create clean and "enriched" chunks"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_chunkr.ipynb.

# %% auto 0
__all__ = ['mistral_api_key', 'src_dir', 'create_fname', 'get_doc_subtype', 'ocr_pdf', 'combine_pages', 'save_page_images',
           'process_pdfs']

# %% ../nbs/04_chunkr.ipynb 2
import os
import re
import time
from io import BytesIO
from dotenv import load_dotenv
import base64
from fastcore.all import *
from rich import print

import pandas as pd
from mistralai import Mistral
from PIL import Image
# from tqdm import tqdm

from .readers import load_evals


# %% ../nbs/04_chunkr.ipynb 3
load_dotenv()
mistral_api_key = os.getenv("MISTRAL_API_KEY")

# %% ../nbs/04_chunkr.ipynb 4
def get_doc_subtype(
    id:str, # ID of the evaluation
    fname:str, # Name of the file
    evals # Evaluations data
    )->str: # Document Subtype
    "Get Document Subtype for a given file in the evaluation dataset"
    eval_data = L(evals).filter(lambda x: x['id']==id)
    if not eval_data: return None
    
    docs = L(eval_data[0]['docs'])
    matches = docs.filter(lambda x: Path(x['File URL']).name==fname)
    return matches[0]['Document Subtype'] if matches else None

# %% ../nbs/04_chunkr.ipynb 9
src_dir = Path("../_data/")

# %% ../nbs/04_chunkr.ipynb 11
def ocr_pdf(
    pdf_path:Union[Path,str], # Path to the PDF file to process
    model:str="mistral-ocr-latest", # Model name to use for OCR processing
    include_images:bool=True, # Whether to include base64-encoded images in the response
    api_key:str=mistral_api_key # Mistral API key for authentication
):
    "Upload a PDF file and process it with OCR in one go"
    if isinstance(pdf_path, str): pdf_path = Path(pdf_path)
    cli = Mistral(api_key=api_key)
    
    uploaded_pdf = cli.files.upload(
        file={
            "file_name": pdf_path.stem,
            "content": pdf_path.read_bytes(),
        },
        purpose="ocr"
    )

    signed_url = cli.files.get_signed_url(file_id=uploaded_pdf.id)
    
    return cli.ocr.process(
        model=model,
        document={
            "type": "document_url",
            "document_url": signed_url.url,
        },
        include_image_base64=include_images
    )

# %% ../nbs/04_chunkr.ipynb 17
def combine_pages(r):
    """Combine all pages into single markdown"""
    return "".join([page.markdown + "\n" for page in r.pages])

# %% ../nbs/04_chunkr.ipynb 18
def save_page_images(
    page, # OCR page object containing images
    dest_folder: Path # Destination folder path
): 
    "Save all images from a page to destination folder as PNG"
    for img in page.images:
        img_data = base64.b64decode(img.image_base64.split(',')[1])
        img_bytes = BytesIO(img_data)
        pil_img = Image.open(img_bytes)
        output_path = dest_folder / img.id
        pil_img.save(output_path)

# %% ../nbs/04_chunkr.ipynb 23
create_fname = lambda row: f'{row.ref_id}_{row.zot_id}'

# %% ../nbs/04_chunkr.ipynb 24
def process_pdfs(
    data: pd.DataFrame,  # Dataframe containing each paper ref_id, zotero_id, n_pages, title, ...
    output_dir: Union[Path, str],  # Base output directory
    model: str = "mistral-ocr-latest",  # OCR model to use
    api_key: str = mistral_api_key,  # Mistral API key
    overwrite: bool = False,  # Whether to overwrite existing files
    pause_seconds: float = 0  # Pause between API calls to respect rate limits
):
    "Process multiple PDFs through OCR and save their content and images"
    output_dir = Path(output_dir)
    
    # for pdf_path in tqdm(pdf_files):
    for _, row in tqdm(data.iterrows(), total=data.shape[0]):
        # pdf_path = Path(pdf_path)
        pdf_path = (Path("../_data/zotero") / row.zot_id).ls(file_exts='.pdf')[0]
        
        pdf_output_dir = output_dir / create_fname(row)
        pdf_output_dir.mkdir(parents=True, exist_ok=True)
        
        img_dir = pdf_output_dir / 'img'
        img_dir.mkdir(exist_ok=True)
        
        # markdown_file = pdf_output_dir / f"{pdf_path.stem}.md"
        markdown_file = pdf_output_dir / 'content.md'
        
        if markdown_file.exists() and not overwrite:
            print(f"Skipping {markdown_file} - output already exists. Use overwrite=True to reprocess.")
            continue
        
        ocr_result = ocr_pdf(pdf_path, model=model, api_key=api_key)
        
        markdown_content = combine_pages(ocr_result)
        markdown_file.write_text(markdown_content)
        
        for page in ocr_result.pages:
            if hasattr(page, 'images') and page.images:
                save_page_images(page, img_dir)
        
        # Pause between files to respect API rate limits
        if pause_seconds > 0: time.sleep(pause_seconds)
